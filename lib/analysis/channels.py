# -*- coding: utf-8 -*-
"""channel_mix_vs_competitors.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zwle3mu1JJTTfJGjlcZqEmWlIop5f7lG

### **Installing packages, importing libraries, setting Poppins as default font**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import io
import re
from google.colab import files
from typing import Optional, Dict, List, Set
from matplotlib.figure import Figure
from matplotlib.axes import Axes
import matplotlib.font_manager as fm

# 1. Download the font file from Google Fonts
font_url = 'https://github.com/google/fonts/raw/main/ofl/poppins/Poppins-Regular.ttf'
font_path = 'Poppins-Regular.ttf'

# Use wget to download quietly
os.system(f'wget -q -O {font_path} {font_url}')

# 2. Add the font to Matplotlib's font manager
fm.fontManager.addfont(font_path)

# 3. Set Poppins as the default font for all plots
# Matplotlib will now find 'Poppins' in its list of available fonts.
plt.rc('font', family='Poppins')

"""### **Defining validation functions**"""

def validate_columns(
    df: pd.DataFrame,
    required_cols: Set[str],
    error_msg: str
) -> bool:
  missing_cols = required_cols - set(df.columns)

  if missing_cols:
    print(f"❌ Error: {error_msg}")
    for col in sorted(list(missing_cols)): # Sorting ensures a consistent error message
      print(f"\t-'{col}'")
    return False

  return True

def validate_df_structure(
    df: pd.DataFrame,
    required_cols: Set[str],
    numeric_cols: Set[str]
) -> bool:
  # 1. Check for missing columns
  if not validate_columns(df, required_cols, "fire is missing required columns."):
    return False

  # 2. Validate numeric columns
  if not numeric_cols.issubset(required_cols):
    print(f"❌ Error: numeric columns not in required columns.")
    return False

  for col in numeric_cols:
    if not pd.api.types.is_numeric_dtype(df[col]):
      print(f"❌ Error: {col} column must contain only numbers.")

  # 3. Return True if DataFrame successfully validated without errors
  print("✅ Success! The DataFrame structure and content have been validated.")
  return True

"""### **Defining cleaning functions**"""

def clean_df(
    raw_df: pd.DataFrame,
    required_cols: Set[str],
    numeric_cols: Set[str]
) -> Optional[pd.DataFrame]:
  """ Ingests raw DF from csv, returns cleaned DF """

  # 1. Create new DF with required cols
  cleaned_df = raw_df[list(required_cols)].copy()

  # 2. Clean columns, type coercion
  cleaned_df['Target'] = cleaned_df['Target'].str.strip().str.lower()
  for col in numeric_cols:
    cleaned_df[col] = pd.to_numeric(cleaned_df[col], errors='coerce').fillna(0)

  # 3. Drop rows where core identifiers, like Target, are missing
  cleaned_df.dropna(subset=['Target'], inplace=True)
  cleaned_df = cleaned_df[cleaned_df['Target'] != '']

  # 4. Drop duplicates
  # Not completely sure I should be dropping or aggregating rows
  cleaned_df.drop_duplicates(subset=['Target'], inplace=True)

  return cleaned_df.astype({
      'Target': 'string',
      **{col: 'int64' for col in numeric_cols}
  })

"""### **Defining upload functions**"""

def check_files_csv(uploaded_files_dict: Dict[str, bytes]) -> bool:
  for file_name in uploaded_files_dict.keys():
    if not file_name.lower().endswith('.csv'):
      _, extension = os.path.splitext(file_name)
      error_type = f"a '{extension}' file" if extension else "a file with no extension"
      print(f"❌ Error: All files must be CSVs. Found {error_type}: '{file_name}'.")
      print(f"\tUpload cancelled. Please upload only CSV files.")
      return False

  return True

def read_files_df(
    uploaded_files_dict: Dict[str, bytes]
) -> Optional[Dict[str, pd.DataFrame]]:
  """ Reads CSVs into a dictionary of DataFrames """
  dataframes = {}

  try:
    for file_name, file_content in uploaded_files_dict.items():
      df = pd.read_csv(io.BytesIO(file_content))
      dataframes[file_name] = df
  except Exception as e:
    # This will catch any file that is a .csv but is malformed inside
    print(f"❌ Error: Could not read the CSV file '{file_name}'. Please ensure it's correctly formatted.")
    print(f"\tDetails: {e}")
    return None

  print(f"✅ Success! All {len(dataframes)} files were read successfully.")
  return dataframes

def handle_file_upload(
    uploaded: Dict[str, bytes]
) -> Optional[Dict[str, pd.DataFrame]]:
  """ Check CSV files have been uploaded and return as a dictionary of DataFrames. """

  if not uploaded:
    print(f"❌ Error: No files uploaded.")
    return None

  if len(uploaded) > 1:
    print(f"❌ Error: Upload only one file. You uploaded {len(uploaded)} files.")
    return None

  if not check_files_csv(uploaded):
    return None

  return read_files_df(uploaded)

def validate_dfs(
    raw_dfs: Dict[str, pd.DataFrame],
    required_cols: Set[str],
    numeric_cols: Set[str]
) -> Optional[Dict[str, pd.DataFrame]]:
  for file_name, df in raw_dfs.items():
    if not validate_df_structure(df, required_cols, numeric_cols):
      print(f"\n❌ Validation failed for file: '{file_name}'")
      return None

  # If all validations pass, return the original dictionary
  return raw_dfs

"""### **Upload CSV File**"""

REQUIRED_COLS = {'Target', 'Direct', 'Referral', 'Organic Search', 'Paid Search', 'Organic Social','Paid Social', 'Email', 'Display Ads'}
NUMERIC_COLS = {'Direct', 'Referral', 'Organic Search', 'Paid Search', 'Organic Social','Paid Social', 'Email', 'Display Ads'}

raw_dfs: Optional[Dict[str, pd.DataFrame]] = None

while raw_dfs is None:
  uploaded = files.upload()
  uploaded_dfs = handle_file_upload(uploaded)

  if uploaded_dfs is None:
    print(f"\nTry again!")
  else:
    raw_dfs = validate_dfs(uploaded_dfs, REQUIRED_COLS, NUMERIC_COLS)

raw_df = next(iter(raw_dfs.values()))

raw_df.info()

raw_df.head()

"""### **Data cleaning**"""

clean_df = clean_df(
    raw_df,
    required_cols=REQUIRED_COLS,
    numeric_cols=NUMERIC_COLS
)

clean_df = clean_df[['Target', 'Direct', 'Referral', 'Organic Search', 'Paid Search', 'Organic Social','Paid Social', 'Email', 'Display Ads']]

clean_df.head()

"""### **Setting colours**"""

GOOGLE_BLUE = '#4285F4'
GOOGLE_RED = '#EA4335'
GOOGLE_YELLOW = '#FBBC05'
GOOGLE_GREEN = '#34A853'

colors = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

"""### **Bar chart**"""

# 1. Prepare the data for plotting by setting the index to 'Target'
#    and then transposing the DataFrame.
data_for_plotting = clean_df.set_index('Target').T

# 2. Create the stacked bar chart using the built-in pandas plot function
fig, ax = plt.subplots(figsize=(12, 8))

data_for_plotting.plot(
    kind='bar',
    stacked=True,
    ax=ax,
    # You can specify colors here if you have a predefined list
    color=colors
)

# 3. Customize the plot for readability
ax.set_title('Traffic by Channel', fontsize=16, pad=20)
ax.set_xlabel('Channel', fontsize=12)
ax.set_ylabel('Total Traffic', fontsize=12)
ax.tick_params(axis='x', rotation=45) # Rotate x-axis labels for better visibility
ax.legend(title='Target')

plt.tight_layout()
plt.show()

# 1. Prepare the data for plotting by setting the index to 'Target'.
#    This tells pandas what to use for the x-axis.
data_for_plotting = clean_df.set_index('Target')

# 2. Create the stacked bar chart.
fig, ax = plt.subplots(figsize=(12, 8))

data_for_plotting.plot(
    kind='bar',
    stacked=True,
    ax=ax,
    # You can specify colors here if you have a predefined list
    color=colors
)

# 3. Customize the plot for readability
ax.set_title('Channel Mix by Target', fontsize=16, pad=20)
ax.set_xlabel('Target', fontsize=12)
ax.set_ylabel('Total Traffic', fontsize=12)
ax.tick_params(axis='x', rotation=45) # Rotate x-axis labels for better visibility
ax.legend(title='Channel')

plt.tight_layout()
plt.show()

# 1. Prepare the data for plotting by setting 'Target' as the index
#    and then transposing the DataFrame.
data_for_plotting = clean_df.set_index('Target').T

# 2. Create the grouped bar chart.
#    By default, kind='bar' creates grouped bars when there are multiple columns.
fig, ax = plt.subplots(figsize=(12, 8))

data_for_plotting.plot(
    kind='bar',
    ax=ax,
    # Note: stacked=False is the default, so we don't need to specify it.
    # You can specify colors here if you have a predefined list
    color=colors
)

# 3. Customize the plot for readability
ax.set_title('Traffic Comparison by Channel and Target', fontsize=16, pad=20)
ax.set_xlabel('Channel', fontsize=12)
ax.set_ylabel('Total Traffic', fontsize=12)
ax.tick_params(axis='x', rotation=45) # Rotate x-axis labels for better visibility
ax.legend(title='Target')

plt.tight_layout()
plt.show()